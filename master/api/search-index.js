var searchIndex = JSON.parse('{\
"cfgrammar":{"doc":"A library for manipulating Context Free Grammars (CFG). It …","t":[12,12,12,12,2,3,3,13,3,2,2,4,3,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,0,11,11,11,11,11,11,11,11,11,0,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,0,12,12,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,8,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,10,11,11,11,11,11,2,13,13,13,13,13,2,2,13,2,2,2,2,2,4,4,0,11,11,11,11,11,11,11,11,11,11,0,11,11,0,11,11,0,11,11,0,11,11,11,11,11,11,11,11,11,11,12,3,3,3,3,13,4,13,12,12,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,12,11,12,12,12,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,12,11,11,12,12,12,12,12,12,12,11,12,12,12,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,3,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,4,13,13,3,6,13,3,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,4,13,13,13,13,13,13,13,3,4,6,3,4,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12],"n":["0","0","0","0","NewlineCache","PIdx","RIdx","Rule","SIdx","Span","Spanned","Symbol","TIdx","Token","as_storaget","as_storaget","as_storaget","as_storaget","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","clone_into","cmp","cmp","cmp","cmp","deserialize","deserialize","deserialize","deserialize","deserialize","eq","eq","eq","eq","eq","equivalent","equivalent","equivalent","equivalent","equivalent","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","hash","hash","hash","hash","hash","into","into","into","into","into","newlinecache","partial_cmp","partial_cmp","partial_cmp","partial_cmp","serialize","serialize","serialize","serialize","serialize","span","to_owned","to_owned","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","yacc","0","0","NewlineCache","borrow","borrow_mut","byte_to_line_byte","byte_to_line_num","byte_to_line_num_and_col_num","feed","from","from_iter","from_str","into","new","span_line_bytes","try_from","try_into","type_id","Span","Spanned","borrow","borrow_mut","clone","clone_into","deserialize","end","eq","equivalent","fmt","from","hash","into","is_empty","len","new","serialize","spans","spanskind","start","to_owned","try_from","try_into","type_id","AssocKind","Eco","GenericParseTree","Grmtools","NoAction","Original","Precedence","SentenceGenerator","UserAction","YaccGrammar","YaccGrammarError","YaccGrammarErrorKind","YaccGrammarWarning","YaccGrammarWarningKind","YaccKind","YaccOriginalActionKind","ast","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","deserialize","deserialize","firsts","fmt","fmt","follows","from","from","grammar","into","into","parser","serialize","serialize","to_owned","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","0","ASTWithValidityInfo","GrammarAST","Production","Rule","Rule","Symbol","Token","action","actiont","add_prod","add_programs","add_rule","ast","avoid_insert","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","epp","errors","expect","expect_unused","expectrr","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","get_rule","has_token","implicit_tokens","into","into","into","into","into","is_valid","name","new","new","parse_param","pidxs","precedence","precs","prods","programs","rules","set_programs","spans","start","symbols","to_owned","to_string","tokens","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","warnings","0","0","1","1","YaccFirsts","borrow","borrow_mut","firsts","fmt","from","into","is_epsilon_set","is_set","new","set","try_from","try_into","type_id","YaccFollows","borrow","borrow_mut","fmt","follows","from","into","is_set","new","try_from","try_into","type_id","AssocKind","Left","Nonassoc","Precedence","PrecedenceLevel","Right","SentenceGenerator","YaccGrammar","action","actiontype","avoid_insert","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","deserialize","deserialize","deserialize","eof_token_idx","eq","eq","expect","expectrr","firsts","fmt","fmt","follows","from","from","from","from","has_path","implicit_rule","into","into","into","into","iter_pidxs","iter_rules","iter_tidxs","kind","level","max_sentence_cost","min_sentence","min_sentence_cost","min_sentences","new","new_from_ast_with_validity_info","new_with_storaget","parse_param","pp_prod","prod","prod_len","prod_precedence","prod_to_rule","prods_len","programs","rule_idx","rule_name","rule_name_span","rule_name_str","rule_to_prods","rules_len","sentence_generator","serialize","serialize","serialize","start_prod","start_rule_idx","to_owned","to_owned","token_epp","token_idx","token_name","token_precedence","token_span","tokens_len","tokens_map","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","DuplicateActiontypeDeclaration","DuplicateAvoidInsertDeclaration","DuplicateEPP","DuplicateExpectDeclaration","DuplicateExpectRRDeclaration","DuplicateImplicitTokensDeclaration","DuplicatePrecedence","DuplicateRule","DuplicateStartDeclaration","DuplicationError","Error","IllegalInteger","IllegalName","IllegalString","IncompleteAction","IncompleteComment","IncompleteRule","InvalidStartRule","InvalidString","MismatchedBrace","MissingColon","MissingRightArrow","NoPrecForToken","NoStartRule","PrecNotFollowedByToken","PrematureEnd","ProgramsNotSupported","ReachedEOL","SpansKind","UnknownDeclaration","UnknownEPP","UnknownRuleRef","UnknownSymbol","UnknownToken","UnusedRule","UnusedToken","YaccGrammarError","YaccGrammarErrorKind","YaccGrammarResult","YaccGrammarWarning","YaccGrammarWarningKind","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone_into","clone_into","clone_into","deserialize","deserialize","eq","eq","eq","eq","equivalent","equivalent","equivalent","equivalent","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","into","into","into","into","into","provide","serialize","serialize","spans","spans","spanskind","spanskind","to_owned","to_owned","to_owned","to_string","to_string","to_string","to_string","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","0","0","0","0","0"],"q":["cfgrammar","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","cfgrammar::Symbol","","cfgrammar::newlinecache","","","","","","","","","","","","","","","","cfgrammar::span","","","","","","","","","","","","","","","","","","","","","","","","","cfgrammar::yacc","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","cfgrammar::yacc::YaccKind","cfgrammar::yacc::ast","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","cfgrammar::yacc::ast::Symbol","","","","cfgrammar::yacc::firsts","","","","","","","","","","","","","","cfgrammar::yacc::follows","","","","","","","","","","","","cfgrammar::yacc::grammar","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","cfgrammar::yacc::parser","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","cfgrammar::yacc::parser::YaccGrammarErrorKind","","","",""],"d":["","","","","","A type specifically for production indices (e.g. a rule …","A type specifically for rule indices.","","A type specifically for symbol indices (within a …","","","","A type specifically for token indices.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Cache newlines from an input. These can be used to turn …","","","Convert a byte offset in the input to the byte offset of …","Convert a byte offset in the input to a logical line …","A convenience method to return the logical line and …","Feed further input into the cache. This input is …","Returns the argument unchanged.","","Construct a <code>NewlineCache</code> directly from a <code>&amp;str</code>. This is …","Calls <code>U::from(self)</code>.","Create an empty <code>NewlineCache</code>.","Return the (start byte, end byte) of the lines containing …","","","","A <code>Span</code> records what portion of the user’s input …","Implemented for errors and warnings to provide access to …","","","","","","Byte offset of the end of the span.","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","Returns <code>true</code> if this <code>Span</code> covers 0 bytes, or <code>false</code> …","Length in bytes of the span.","Create a new span starting at byte <code>start</code> and ending at …","","Returns the spans associated with the error, always …","Returns the <code>SpansKind</code> associated with this error.","Byte offset of the start of the span.","","","","","","The variant used in the Eco language composition editor","Automatically create a parse tree instead of …","Similar to the original Yacc style, but allowing …","Do not do execute actions of any sort.","The original Yacc style as documented by Johnson,","","","Execute user-specified actions attached to each …","","","","","","The particular Yacc variant this grammar makes use of.","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","Contains a <code>GrammarAST</code> structure produced from a grammar …","An AST representing a grammar. This is built up gradually: …","","","","","","","","","","","Returns a <code>GrammarAST</code> constructed as the result of parsing …","","","","","","","","","","","","","","","Returns all errors which were encountered during AST …","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Returns whether any errors where encountered during the …","","Parses a source file into an AST, returning an ast and any …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","<code>Firsts</code> stores all the first sets for a given grammar. For …","","","Return all the firsts for rule <code>ridx</code>.","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Returns true if the rule <code>ridx</code> has epsilon in its first set.","Returns true if the token <code>tidx</code> is in the first set for …","Generates and returns the firsts set for the given grammar.","Ensures that the firsts bit for token <code>tidx</code> rule <code>ridx</code> is …","","","","<code>Follows</code> stores all the Follow sets for a given grammar. …","","","","Return the Follows <code>Vob</code> for rule <code>ridx</code>.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Returns true if the token <code>tidx</code> is in the follow set for …","Generates and returns the Follows set for the given …","","","","","","","","","","A <code>SentenceGenerator</code> can generate minimal sentences for any …","Representation of a <code>YaccGrammar</code>. See the top-level …","Get the action for production <code>pidx</code>. Panics if <code>pidx</code> doesn’…","","Is the token <code>tidx</code> marked as <code>%avoid_insert</code>?","","","","","","","","","","","","","","","","Return the index of the end token.","","","","","Return a <code>YaccFirsts</code> struct for this grammar.","","","Return a <code>YaccFirsts</code> struct for this grammar.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Is there a path from the <code>from</code> rule to the <code>to</code> rule? Note …","Return the <code>RIdx</code> of the implict rule if it exists, or <code>None</code> …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Return an iterator which produces (in order from …","Return an iterator which produces (in order from …","Return an iterator which produces (in order from …","","","What is the cost of a maximal sentence for the rule <code>ridx</code>? …","Non-deterministically return a minimal sentence from the …","What is the cost of a minimal sentence for the rule <code>ridx</code>? …","Return (in arbitrary order) all the minimal sentences for …","","","Takes as input a Yacc grammar of <code>YaccKind</code> as a <code>String</code> <code>s</code> …","","Returns the string representation of a given production …","Get the sequence of symbols for production <code>pidx</code>. Panics if …","How many symbols does production <code>pidx</code> have? Panics if <code>pidx</code> …","Return the precedence of production <code>pidx</code> (where <code>None</code> …","Return the rule index of the production <code>pidx</code>. Panics if …","How many productions does this grammar have?","Get the programs part of the grammar","Return the index of the rule named <code>n</code> or <code>None</code> if it doesn’…","Return the name of rule <code>ridx</code>. Panics if <code>ridx</code> doesn’t …","Return the span of rule <code>ridx</code>. Panics if <code>ridx</code> doesn’t …","Return the name of rule <code>ridx</code>. Panics if <code>ridx</code> doesn’t …","Return the productions for rule <code>ridx</code>. Panics if <code>ridx</code> doesn…","How many rules does this grammar have?","Return a <code>SentenceGenerator</code> which can then generate minimal …","","","","Return the production index of the start rule’s sole …","What is the index of the start rule? Note that cfgrammar …","","","Return the %epp entry for token <code>tidx</code> (where <code>None</code> indicates …","Return the index of the token named <code>n</code> or <code>None</code> if it doesn…","Return the name of token <code>tidx</code> (where <code>None</code> indicates “the …","Return the precedence of token <code>tidx</code> (where <code>None</code> indicates …","Return the span for token given by <code>tidx</code> if one exists. If …","How many tokens does this grammar have?","Returns a map from names to <code>TIdx</code>s of all tokens that a …","","","","","","","","","","","","","","","","","","","","","","The first span is the first occurrence, and a span for …","Contains a single span at the site of the error.","","","","","","","","","","","","","","","","","","Indicates how to interpret the spans of an error.","","","","","","","","Any error from the Yacc parser returns an instance of this …","The various different possible Yacc parser errors.","","Any Warning from the Yacc parser returns an instance of …","The various different possible Yacc parser errors.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","Returns the spans associated with the error, always …","Returns the spans associated with the error, always …","Returns the SpansKind associated with this error.","Returns the SpansKind associated with this error.","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[3,4,5,6,0,0,0,8,0,0,0,0,0,8,3,4,5,6,3,4,5,6,8,3,4,5,6,8,3,4,5,6,8,3,4,5,6,8,3,4,5,6,3,4,5,6,8,3,4,5,6,8,3,4,5,6,8,3,4,5,6,8,3,4,5,6,8,3,4,5,6,8,3,4,5,6,8,0,3,4,5,6,3,4,5,6,8,0,3,4,5,6,8,3,4,5,6,8,3,4,5,6,8,3,4,5,6,8,0,52,53,0,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,0,0,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,54,54,24,24,24,24,24,0,26,27,26,27,26,0,0,27,0,0,0,0,0,0,0,0,26,27,26,27,26,27,26,27,26,27,0,26,27,0,26,27,0,26,27,0,26,27,26,27,26,27,26,27,26,27,55,0,0,0,0,30,0,30,34,33,28,28,28,32,28,32,28,33,34,30,32,28,33,34,30,30,30,28,32,28,28,28,28,33,34,30,30,32,28,33,34,30,28,28,28,32,28,33,34,30,32,33,32,28,28,33,34,28,28,28,28,28,28,28,34,30,30,28,32,28,33,34,30,32,28,33,34,30,32,28,33,34,30,28,56,57,56,57,0,36,36,36,36,36,36,36,36,36,36,36,36,36,0,39,39,39,39,39,39,39,39,39,39,39,0,41,41,0,0,41,0,0,38,38,38,43,40,41,38,43,40,41,38,40,41,40,41,40,41,38,38,40,41,38,38,38,40,41,38,43,40,41,38,38,38,43,40,41,38,38,38,38,40,40,43,43,43,43,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,40,41,38,38,38,40,41,38,38,38,38,38,38,38,43,40,41,38,43,40,41,38,43,40,41,38,48,48,48,48,48,48,48,48,48,25,25,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,0,48,48,48,48,48,49,49,0,0,0,0,0,25,48,50,49,35,25,48,50,49,35,48,49,35,48,49,35,49,35,48,50,49,35,48,50,49,35,48,48,50,50,49,49,35,35,25,48,50,49,35,25,48,50,49,35,50,49,35,50,35,50,35,48,49,35,48,50,49,35,25,48,50,49,35,25,48,50,49,35,25,48,50,49,35,58,59,60,61,62],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[[3,[[0,[1,2]]]]],[[0,[1,2]]]],[[[4,[[0,[1,2]]]]],[[0,[1,2]]]],[[[5,[[0,[1,2]]]]],[[0,[1,2]]]],[[[6,[[0,[1,2]]]]],[[0,[1,2]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[[3,[7]]],[[3,[7]]]],[[[4,[7]]],[[4,[7]]]],[[[5,[7]]],[[5,[7]]]],[[[6,[7]]],[[6,[7]]]],[[[8,[7]]],[[8,[7]]]],[[]],[[]],[[]],[[]],[[]],[[[3,[9]],3],10],[[[4,[9]],4],10],[[[5,[9]],5],10],[[[6,[9]],6],10],[[],[[11,[3]]]],[[],[[11,[4]]]],[[],[[11,[5]]]],[[],[[11,[6]]]],[[],[[11,[8]]]],[[[3,[12]],3],13],[[[4,[12]],4],13],[[[5,[12]],5],13],[[[6,[12]],6],13],[[[8,[12]],8],13],[[],13],[[],13],[[],13],[[],13],[[],13],[[[3,[14]],15],16],[[[4,[14]],15],16],[[[5,[14]],15],16],[[[6,[14]],15],16],[[[8,[14]],15],16],[[]],[[]],[[]],[[]],[[]],[[[3,[17]]]],[[[4,[17]]]],[[[5,[17]]]],[[[6,[17]]]],[[[8,[17]]]],[[]],[[]],[[]],[[]],[[]],0,[[[3,[18]],3],[[19,[10]]]],[[[4,[18]],4],[[19,[10]]]],[[[5,[18]],5],[[19,[10]]]],[[[6,[18]],6],[[19,[10]]]],[3,11],[4,11],[5,11],[6,11],[8,11],0,[[]],[[]],[[]],[[]],[[]],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],20],[[],20],[[],20],[[],20],[[],20],0,0,0,0,[[]],[[]],[[21,22],[[19,[22]]]],[[21,22],[[19,[22]]]],[[21,23,22],19],[[21,23]],[[]],[[],21],[23,[[11,[21]]]],[[]],[[],21],[[21,24]],[[],11],[[],11],[[],20],0,0,[[]],[[]],[24,24],[[]],[[],[[11,[24]]]],[24,22],[[24,24],13],[[],13],[[24,15],16],[[]],[24],[[]],[24,13],[24,22],[[22,22],24],[24,11],[[]],[[],25],[24,22],[[]],[[],11],[[],11],[[],20],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[]],[[]],[[]],[[]],[26,26],[27,27],[[]],[[]],[[],[[11,[26]]]],[[],[[11,[27]]]],0,[[26,15],16],[[27,15],16],0,[[]],[[]],0,[[]],[[]],0,[26,11],[27,11],[[]],[[]],[[],11],[[],11],[[],11],[[],11],[[],20],[[],20],0,0,0,0,0,0,0,0,0,0,[[28,29,[31,[30]],[19,[29]],[19,[29]]]],[[28,29]],[[28,[19,[29]]]],[32,28],0,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[30,30],[[]],0,[32],0,0,0,[[28,15],16],[[33,15],16],[[34,15],16],[[30,15],16],[[30,15],16],[[]],[[]],[[]],[[]],[[]],[[28,23],[[19,[33]]]],[[28,23],13],0,[[]],[[]],[[]],[[]],[[]],[32,13],0,[[26,23],32],[[],28],0,0,0,0,0,0,0,[[28,29]],0,0,0,[[]],[[],29],0,[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],20],[[],20],[[],20],[[],20],[[],20],[28,[[31,[35]]]],0,0,0,0,0,[[]],[[]],[[[36,[[0,[1,2]]]],[3,[[0,[1,2]]]]],37],[[[36,[14]],15],16],[[]],[[]],[[[36,[[0,[1,2]]]],[3,[[0,[1,2]]]]],13],[[[36,[[0,[1,2]]]],[3,[[0,[1,2]]]],[6,[[0,[1,2]]]]],13],[38,[[36,[[0,[1,2]]]]]],[[[36,[[0,[1,2]]]],[3,[[0,[1,2]]]],[6,[[0,[1,2]]]]],13],[[],11],[[],11],[[],20],0,[[]],[[]],[[[39,[14]],15],16],[[[39,[[0,[1,2]]]],[3,[[0,[1,2]]]]],37],[[]],[[]],[[[39,[[0,[1,2]]]],[3,[[0,[1,2]]]],[6,[[0,[1,2]]]]],13],[38,[[39,[[0,[1,2]]]]]],[[],11],[[],11],[[],20],0,0,0,0,0,0,0,0,[[[38,[[0,[1,2]]]],[4,[[0,[1,2]]]]],19],[[[38,[[0,[1,2]]]],[3,[[0,[1,2]]]]],19],[[[38,[[0,[1,2]]]],[6,[[0,[1,2]]]]],13],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[40,40],[41,41],[[]],[[]],[[],[[11,[40]]]],[[],[[11,[41]]]],[[],[[11,[38]]]],[[[38,[[0,[1,2]]]]],[[6,[[0,[1,2]]]]]],[[40,40],13],[[41,41],13],[[[38,[[0,[1,2]]]]],[[19,[22]]]],[[[38,[[0,[1,2]]]]],[[19,[22]]]],[[[38,[[0,[1,2]]]]],[[36,[[0,[1,2]]]]]],[[40,15],16],[[41,15],16],[[[38,[[0,[1,2]]]]],[[39,[[0,[1,2]]]]]],[[]],[[]],[[]],[[]],[[[38,[[0,[1,2]]]],[3,[[0,[1,2]]]],[3,[[0,[1,2]]]]],13],[[[38,[[0,[1,2]]]]],[[19,[[3,[[0,[1,2]]]]]]]],[[]],[[]],[[]],[[]],[[[38,[[0,[1,2]]]]],42],[[[38,[[0,[1,2]]]]],42],[[[38,[[0,[1,2]]]]],42],0,0,[[[43,[[0,[1,2]]]],[3,[[0,[1,2]]]]],[[19,[44]]]],[[[43,[[0,[1,2]]]],[3,[[0,[1,2]]]]],[[31,[[6,[[0,[1,2]]]]]]]],[[[43,[[0,[1,2]]]],[3,[[0,[1,2]]]]],44],[[[43,[[0,[1,2]]]],[3,[[0,[1,2]]]]],[[31,[[31,[[6,[[0,[1,2]]]]]]]]]],[[26,23],[[46,[[38,[45]]]]]],[[26,32],[[46,[[38,[[0,[1,2]]]]]]]],[[26,23],[[46,[[38,[[0,[1,2]]]]]]]],[[[38,[[0,[1,2]]]]],19],[[[38,[[0,[1,2]]]],[4,[[0,[1,2]]]]],29],[[[38,[[0,[1,2]]]],[4,[[0,[1,2]]]]]],[[[38,[[0,[1,2]]]],[4,[[0,[1,2]]]]],[[5,[[0,[1,2]]]]]],[[[38,[[0,[1,2]]]],[4,[[0,[1,2]]]]],[[19,[40]]]],[[[38,[[0,[1,2]]]],[4,[[0,[1,2]]]]],[[3,[[0,[1,2]]]]]],[[[38,[[0,[1,2]]]]],[[4,[[0,[1,2]]]]]],[[[38,[[0,[1,2]]]]],19],[[[38,[[0,[1,2]]]],23],[[19,[[3,[[0,[1,2]]]]]]]],[[[38,[[0,[1,2]]]],[3,[[0,[1,2]]]]],23],[[[38,[[0,[1,2]]]],[3,[[0,[1,2]]]]],24],[[[38,[[0,[1,2]]]],[3,[[0,[1,2]]]]],23],[[[38,[[0,[1,2]]]],[3,[[0,[1,2]]]]]],[[[38,[[0,[1,2]]]]],[[3,[[0,[1,2]]]]]],[[[38,[[0,[1,2]]]]],[[43,[[0,[1,2]]]]]],[40,11],[41,11],[38,11],[[[38,[[0,[1,2]]]]],[[4,[[0,[1,2]]]]]],[[[38,[[0,[1,2]]]]],[[3,[[0,[1,2]]]]]],[[]],[[]],[[[38,[[0,[1,2]]]],[6,[[0,[1,2]]]]],[[19,[23]]]],[[[38,[[0,[1,2]]]],23],[[19,[[6,[[0,[1,2]]]]]]]],[[[38,[[0,[1,2]]]],[6,[[0,[1,2]]]]],[[19,[23]]]],[[[38,[[0,[1,2]]]],[6,[[0,[1,2]]]]],[[19,[40]]]],[[[38,[[0,[1,2]]]],[6,[[0,[1,2]]]]],[[19,[24]]]],[[[38,[[0,[1,2]]]]],[[6,[[0,[1,2]]]]]],[[[38,[[0,[1,2]]]]],[[47,[23,[6,[[0,[1,2]]]]]]]],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],20],[[],20],[[],20],[[],20],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[48,48],[49,49],[35,35],[[]],[[]],[[]],[[],[[11,[49]]]],[[],[[11,[35]]]],[[48,48],13],[[50,50],13],[[49,49],13],[[35,35],13],[[],13],[[],13],[[],13],[[],13],[[48,15],16],[[48,15],16],[[50,15],16],[[50,15],16],[[49,15],16],[[49,15],16],[[35,15],16],[[35,15],16],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[51],[49,11],[35,11],[50],[35],[50,25],[35,25],[[]],[[]],[[]],[[],29],[[],29],[[],29],[[],29],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],20],[[],20],[[],20],[[],20],[[],20],0,0,0,0,0],"p":[[8,"PrimInt"],[8,"Unsigned"],[3,"RIdx"],[3,"PIdx"],[3,"SIdx"],[3,"TIdx"],[8,"Clone"],[4,"Symbol"],[8,"Ord"],[4,"Ordering"],[4,"Result"],[8,"PartialEq"],[15,"bool"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[8,"Hash"],[8,"PartialOrd"],[4,"Option"],[3,"TypeId"],[3,"NewlineCache"],[15,"usize"],[15,"str"],[3,"Span"],[4,"SpansKind"],[4,"YaccKind"],[4,"YaccOriginalActionKind"],[3,"GrammarAST"],[3,"String"],[4,"Symbol"],[3,"Vec"],[3,"ASTWithValidityInfo"],[3,"Rule"],[3,"Production"],[3,"YaccGrammarWarning"],[3,"YaccFirsts"],[3,"Vob"],[3,"YaccGrammar"],[3,"YaccFollows"],[3,"Precedence"],[4,"AssocKind"],[8,"Iterator"],[3,"SentenceGenerator"],[15,"u16"],[15,"u32"],[6,"YaccGrammarResult"],[3,"HashMap"],[4,"YaccGrammarErrorKind"],[4,"YaccGrammarWarningKind"],[3,"YaccGrammarError"],[3,"Demand"],[13,"Rule"],[13,"Token"],[8,"Spanned"],[13,"Original"],[13,"Rule"],[13,"Token"],[13,"InvalidStartRule"],[13,"UnknownRuleRef"],[13,"UnknownToken"],[13,"NoPrecForToken"],[13,"UnknownEPP"]]},\
"lrlex":{"doc":"<code>lrlex</code> is a partial replacement for <code>lex</code> / <code>flex</code>. It takes in …","t":[3,3,3,13,13,13,13,13,3,13,3,3,6,4,6,8,4,13,6,13,13,13,13,13,13,13,13,13,13,13,4,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,5,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,10,11,10,11,10,11,11,11,11,11,11,11,11,11,11,11,11,10,11,10,11,11,11,11,11,11,14,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12],"n":["CTLexer","CTLexerBuilder","DefaultLexeme","DuplicateName","DuplicateStartState","InvalidName","InvalidStartState","InvalidStartStateName","LRNonStreamingLexer","LRNonStreamingLexer","LRNonStreamingLexerDef","LexBuildError","LexBuildResult","LexErrorKind","LexerBuilder","LexerDef","LexerKind","MissingSpace","NonStreamingLexerDef","PrematureEnd","Private","Public","PublicCrate","PublicIn","PublicSelf","PublicSuper","RegexError","RoutinesNotSupported","UnknownDeclaration","UnknownStartState","Visibility","allow_missing_terms_in_lexer","allow_missing_tokens_in_parser","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","build","clone","clone","clone","clone_into","clone_into","clone_into","ct_token_map","eq","eq","eq","equivalent","equivalent","equivalent","faulty","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from","from_str","from_str","get_rule","get_rule","get_rule_by_id","get_rule_by_id","get_rule_by_name","get_rule_by_name","hash","into","into","into","into","into","into","into","into","into","iter","iter_rules","iter_rules","iter_start_states","iter_start_states","lexer","lexer_in_src_dir","lexer_path","lexerkind","line_col","lrlex_mod","lrpar_config","mod_name","new","new","new","new_faulty","new_with_lexemet","output_path","process_file","process_file_in_src","provide","provide","rule_ids_map","set_rule_ids","set_rule_ids","span","span_lines_str","span_str","spans","spanskind","to_owned","to_owned","to_owned","to_string","to_string","tok_id","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","visibility","0"],"q":["lrlex","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","lrlex::Visibility"],"d":["An interface to the result of CTLexerBuilder::build().","A <code>CTLexerBuilder</code> allows one to specify the criteria for …","lrlex’s standard lexeme struct: all lexemes are …","","","","","","An <code>LRNonStreamingLexer</code> holds a reference to a string and …","","This struct represents, in essence, a .l file in memory. …","Any error from the Lex parser returns an instance of this …","","The various different possible Lex parser errors.","","Methods which all lexer definitions must implement.","","","","","Module-level visibility only.","<code>pub</code>","<code>pub(crate)</code>","<code>pub(in {arg})</code>","<code>pub(self)</code>","<code>pub(super)</code>","","","","","Specify the visibility of the module generated by …","If passed false, tokens used in the grammar but not …","If passed false, tokens defined in the lexer but not used …","","","","","","","","","","","","","","","","","","","Statically compile the <code>.l</code> file specified by …","","","","","","","Create a Rust module named <code>mod_name</code> that can be imported …","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Instantiate a lexer from a string (e.g. representing a <code>.l</code> …","","Get the <code>Rule</code> at index <code>idx</code>.","","Get the <code>Rule</code> instance associated with a particular lexeme …","","Get the <code>Rule</code> instance associated with a particular name.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","Returns an iterator over all rules in this AST.","","Returns an iterator over all start states in this AST.","","Return an LRNonStreamingLexer for the <code>String</code> <code>s</code> that will …","Set the input lexer path to a file relative to this project…","Set the input lexer path to <code>inp</code>. If specified, you must …","Set the type of lexer to be generated to <code>lexerkind</code>.","","A convenience macro for including statically compiled <code>.l</code> …","An optional convenience function to make it easier to …","Set the generated module name to <code>mod_name</code>. If no module …","Create a new CTLexerBuilder.","Create a new <code>LRNonStreamingLexer</code> that read in: the input <code>s</code>…","","","Create a new CTLexerBuilder.","Set the output lexer path to <code>outp</code>. Note that there are no …","Statically compile the <code>.l</code> file <code>inp</code> into Rust, placing the …","Given the filename <code>a/b.l</code> as input, statically compile the …","","","Set this lexer builder’s map of rule IDs to <code>rule_ids_map</code>…","Set the id attribute on rules to the corresponding value …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Set the visibility of the generated module to <code>vis</code>. …",""],"i":[0,0,0,11,11,11,11,11,0,32,0,0,0,0,0,0,0,11,0,11,7,7,7,7,7,7,11,11,11,11,0,1,1,32,1,3,27,29,7,10,21,11,32,1,3,27,29,7,10,21,11,1,7,10,11,7,10,11,0,7,10,11,7,10,11,10,7,10,10,21,21,11,32,1,3,27,29,7,10,21,11,43,27,43,27,43,27,43,27,10,32,1,3,27,29,7,10,21,11,29,43,27,43,27,27,1,1,1,29,0,1,1,1,29,10,10,1,1,1,1,10,21,1,43,27,10,29,29,21,21,7,10,11,10,21,10,32,1,3,27,29,7,10,21,11,32,32,1,1,3,3,27,27,29,29,7,7,10,10,21,21,11,11,32,1,3,27,29,7,10,21,11,1,44],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[1,2],1],[[1,2],1],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[1,[[6,[3,[5,[4]]]]]],[7,7],[[[10,[[0,[8,9]]]]],[[10,[[0,[8,9]]]]]],[11,11],[[]],[[]],[[]],[[12,13,[14,[13]]],[[6,[[5,[4]]]]]],[[7,7],2],[[[10,[[0,[15,9]]]],10],2],[[11,11],2],[[],2],[[],2],[[],2],[[[10,[[0,[16,9,17,18]]]]],2],[[7,19],20],[[[10,[[0,[9,9]]]],19],20],[[[10,[[0,[16,9,18,17,16]]]],19],20],[[21,19],20],[[21,19],20],[[11,19],20],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[12,22],[12,[[22,[[27,[[0,[16,18,17,23,[25,[24]],26]]]]]]]],[24,[[14,[0]]]],[[[27,[[0,[16,18,17,23,[25,[24]],26]]]],24],[[14,[0]]]],0,0,[12,[[14,[0]]]],[[[27,[[0,[16,18,17,23,[25,[24]],26]]]],12],[[14,[0]]]],[[[10,[[0,[17,9]]]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[[29,[[28,[[0,[16,9,18,17,23,26]]]],[0,[16,9,18,17,23,26]]]]],[[5,[30]]]],[[],[[31,[0]]]],[[[27,[[0,[16,18,17,23,[25,[24]],26]]]]],[[31,[[0,[[0,[16,18,17,23,[25,[24]],26]]]]]]]],[[],[[31,[0]]]],[[[27,[[0,[16,18,17,23,[25,[24]],26]]]]],[[31,[0]]]],[[[27,[[28,[[0,[16,18,9,17,23,[25,[24]],26]]]],[0,[16,18,9,17,23,[25,[24]],26]]]],12],[[29,[[28,[[0,[16,18,9,17,23,[25,[24]],26]]]],[0,[16,18,9,17,23,[25,[24]],26]]]]]],[1,[[6,[1,[5,[4]]]]]],[1,1],[[1,32],1],[[[29,[[28,[[0,[16,18,9,17,23,26]]]],[0,[16,18,9,17,23,26]]]],33]],0,[1,1],[[1,12],1],[[],[[1,[[10,[34]],34]]]],[[12,[36,[[6,[[28,[[0,[16,18,9,17,23,[25,[24]],26]]]],35]]]],37],[[29,[[28,[[0,[16,18,9,17,23,[25,[24]],26]]]],[0,[16,18,9,17,23,[25,[24]],26]]]]]],[[[0,[16,9,17,18]],24,24],[[10,[[0,[16,9,17,18]]]]]],[[[0,[16,9,17,18]],24,24],[[10,[[0,[16,9,17,18]]]]]],[[],1],[1,1],[1,[[6,[[5,[4]]]]]],[[1,12],[[6,[[5,[4]]]]]],[38],[38],[[1,[0,[[40,[[13,[39]]]],8]]],1],[13],[[[27,[[0,[16,18,17,23,[25,[24]],26]]]],13]],[[[10,[[0,[16,9,17,18]]]]],33],[[[29,[[28,[[0,[16,18,9,17,23,26]]]],[0,[16,18,9,17,23,26]]]],33],12],[[[29,[[28,[[0,[16,18,9,17,23,26]]]],[0,[16,18,9,17,23,26]]]],33],12],[21],[21,41],[[]],[[]],[[]],[[],39],[[],39],[[[10,[[0,[16,9,17,18]]]]],[[0,[16,9,17,18]]]],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],6],[[],42],[[],42],[[],42],[[],42],[[],42],[[],42],[[],42],[[],42],[[],42],[[1,7],1],0],"p":[[3,"CTLexerBuilder"],[15,"bool"],[3,"CTLexer"],[8,"Error"],[3,"Box"],[4,"Result"],[4,"Visibility"],[8,"Clone"],[8,"Debug"],[3,"DefaultLexeme"],[4,"LexErrorKind"],[15,"str"],[3,"HashMap"],[4,"Option"],[8,"PartialEq"],[8,"Copy"],[8,"Hash"],[8,"Eq"],[3,"Formatter"],[6,"Result"],[3,"LexBuildError"],[6,"LexBuildResult"],[8,"PrimInt"],[15,"usize"],[8,"TryFrom"],[8,"Unsigned"],[3,"LRNonStreamingLexerDef"],[8,"Lexeme"],[3,"LRNonStreamingLexer"],[8,"Iterator"],[3,"Iter"],[4,"LexerKind"],[3,"Span"],[15,"u32"],[3,"LexError"],[3,"Vec"],[3,"NewlineCache"],[3,"Demand"],[3,"String"],[8,"Borrow"],[4,"SpansKind"],[3,"TypeId"],[8,"LexerDef"],[13,"PublicIn"]]},\
"lrpar":{"doc":"<code>lrpar</code> provides a Yacc-compatible parser (where grammars …","t":[13,3,3,13,13,3,13,4,8,8,4,8,13,13,3,13,4,13,13,13,13,13,13,3,4,13,3,13,4,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,10,14,11,10,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12],"n":["CPCTPlus","CTParser","CTParserBuilder","Delete","Insert","LexError","LexError","LexParseError","Lexeme","Lexer","Node","NonStreamingLexer","None","Nonterm","ParseError","ParseError","ParseRepair","Private","Public","PublicCrate","PublicIn","PublicSelf","PublicSuper","RTParserBuilder","RecoveryKind","Shift","Span","Term","Visibility","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","build","clone","clone","clone","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","conflicts","deserialize","deserialize","end","eq","eq","eq","eq","eq","equivalent","equivalent","equivalent","error_on_conflicts","faulty","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from","from","from","from","from","grammar_in_src_dir","grammar_path","hash","hash","into","into","into","into","into","into","into","into","into","into","into","is_empty","iter","len","lexeme","line_col","lrpar_mod","mod_name","new","new","new","new","new","new_faulty","output_path","parse_actions","parse_generictree","parse_noaction","pp","pp","process_file","process_file_in_src","provide","provide","provide","recoverer","recoverer","regenerated","repairs","serialize","serialize","show_warnings","span","span","span_lines_str","span_str","start","stidx","term_costs","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_string","to_string","to_string","tok_id","token_map","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","visibility","warnings_are_errors","yacckind","0","0","lexeme","nodes","ridx","0","0","0","0"],"q":["lrpar","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","lrpar::LexParseError","","lrpar::Node","","","lrpar::ParseRepair","","","lrpar::Visibility"],"d":["The CPCT+ algorithm from Diekmann/Tratt “Don’t Panic! …","An interface to the result of CTParserBuilder::build().","A <code>CTParserBuilder</code> allows one to specify the criteria for …","Delete a symbol.","Insert a <code>Symbol::Token</code>.","A Lexing error.","","A lexing or parsing error. Although the two are quite …","A lexeme represents a segment of the user’s input that …","The base trait which all lexers which want to interact …","A generic parse tree.","A <code>NonStreamingLexer</code> is one that takes input in one go, and …","Don’t use error recovery: return as soon as the first …","Nonterminals reference a rule and have zero or more <code>Node</code>s …","Records a single parse error.","","After a parse error is encountered, the parser attempts to …","Module-level visibility only.","<code>pub</code>","<code>pub(crate)</code>","<code>pub(in {arg})</code>","<code>pub(self)</code>","<code>pub(super)</code>","A run-time parser builder.","What recovery algorithm should be used when a syntax error …","Shift a symbol.","A <code>Span</code> records what portion of the user’s input …","Terminals store a single lexeme.","Specify the visibility of the module generated by <code>CTBuilder</code>…","","","","","","","","","","","","","","","","","","","","","","","Statically compile the Yacc file specified by …","","","","","","","","","","","","","","","If there are any conflicts in the grammar, return a tuple …","","","Byte offset of the end of the span.","","","","","","","","","If set to true, CTParserBuilder::build will return an …","Returns <code>true</code> if this lexeme is “faulty” i.e. is the …","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","Returns the argument unchanged.","","Returns the argument unchanged.","Returns the argument unchanged.","Set the input grammar path to a file relative to this …","Set the input grammar path to <code>inp</code>. If specified, you must …","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Returns <code>true</code> if this <code>Span</code> covers 0 bytes, or <code>false</code> …","Iterate over all the lexemes in this lexer. Note that:","Length in bytes of the span.","Return the lexeme where this error was detected.","Return <code>((start line, start column), (end line, end column))</code>…","A convenience macro for including statically compiled <code>.y</code> …","Set the generated module name to <code>mod_name</code>. If no module …","Create a new lexeme with ID <code>tok_id</code>, a starting position in …","Create a new <code>CTParserBuilder</code>.","Create a new run-time parser from a <code>YaccGrammar</code>, and a …","Create a new span starting at byte <code>start</code> and ending at …","","Create a new faulty lexeme with ID <code>tok_id</code> and a starting …","Set the output grammar path to <code>outp</code>. Note that there are …","Parse input, execute actions, and return the associated …","Parse input, and (if possible) return a generic parse …","Parse input, returning any errors found. See the arguments …","Return a pretty-printed version of this node.","A pretty-printer of a lexer/parser error. This isn’t …","Statically compile the Yacc file <code>inp</code> into Rust, placing …","Given the filename <code>a/b.y</code> as input, statically compile the …","","","","Set the recoverer for this parser to <code>rk</code>. Defaults to …","Set the recoverer for this parser to <code>rk</code>.","Returns <code>true</code> if this compile-time parser was regenerated …","Return the repairs found that would fix this error. Note …","","","If set to true, CTParserBuilder::build will print warnings …","Obtain this <code>Lexeme</code>’s Span.","","Return the lines containing the input at <code>span</code> (including …","Return the user input associated with a Span.","Byte offset of the start of the span.","Return the state table index where this error was detected.","","","","","","","","","","","","The token ID.","Returns a HashMap from lexeme string types to numeric …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Set the visibility of the generated module to <code>vis</code>. …","If set to true, CTParserBuilder::build will return an …","Set the <code>YaccKind</code> for this parser to <code>ak</code>.","","","","","","","","",""],"i":[12,0,0,14,14,0,24,0,0,0,0,0,12,11,0,24,0,6,6,6,6,6,6,0,0,14,0,11,0,1,2,31,6,7,8,11,12,24,14,15,1,2,31,6,7,8,11,12,24,14,15,1,6,7,8,11,12,14,15,6,7,8,11,12,14,15,2,7,12,7,6,7,11,14,15,6,7,14,1,10,6,7,8,8,11,12,24,24,14,15,15,1,2,31,6,7,8,11,12,24,24,24,14,15,1,1,7,14,1,2,31,6,7,8,11,12,24,14,15,7,42,7,15,32,0,1,10,1,31,7,8,10,1,31,31,31,11,24,1,1,8,24,15,1,31,2,15,7,12,1,10,8,32,32,7,15,31,6,7,8,11,12,14,15,8,24,15,10,2,1,2,31,6,7,8,11,12,24,14,15,1,2,31,6,7,8,11,12,24,14,15,1,2,31,6,7,8,11,12,24,14,15,1,1,1,43,44,45,46,46,47,48,49,50],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[1,[[5,[2,[4,[3]]]]]],[6,6],[7,7],[8,8],[[[11,[[0,[9,[10,[9]]]],9]]],[[11,[[0,[9,[10,[9]]]],9]]]],[12,12],[[[14,[[0,[9,[10,[[0,[9,13]]]]]],[0,[9,13]]]]],[[14,[[0,[9,[10,[[0,[9,13]]]]]],[0,[9,13]]]]]],[[[15,[[0,[9,[10,[[0,[9,13]]]]]],[0,[9,13]]]]],[[15,[[0,[9,[10,[[0,[9,13]]]]]],[0,[9,13]]]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[2,16],[[],[[5,[7]]]],[[],[[5,[12]]]],[7,17],[[6,6],18],[[7,7],18],[[[11,[[0,[19,[10,[19]]]],19]],11],18],[[[14,[[0,[19,[10,[[0,[19,13]]]]]],[0,[19,13]]]],14],18],[[[15,[[0,[19,[10,[[0,[19,13]]]]]],[0,[19,13]]]],15],18],[[],18],[[],18],[[],18],[[1,18],1],[[],18],[[6,20],21],[[7,20],[[5,[22]]]],[[8,20],21],[[8,20],21],[[[11,[[0,[23,[10,[23]]]],23]],20],21],[[12,20],21],[[[24,[[10,[[0,[23,13]]]],[0,[23,13]]]],20],21],[[[24,[[0,[23,[10,[[0,[23,13]]]]]],[0,[23,13]]]],20],21],[[[14,[[0,[23,[10,[[0,[23,13]]]]]],[0,[23,13]]]],20],21],[[[15,[[0,[23,[10,[[0,[23,13]]]]]],[0,[23,13]]]],20],21],[[[15,[[10,[[0,[23,13]]]],[0,[23,13]]]],20],21],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[[15,[[10,[13]],13]]],[[24,[[10,[13]],13]]]],[[]],[8,[[24,[[10,[13]],13]]]],[[]],[[]],[1,[[5,[1,[4,[3]]]]]],[1,1],[7],[[[14,[[0,[13,[10,[[0,[13,13]]]]]],[0,[13,13]]]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[7,18],[[],[[4,[25]]]],[7,17],[[[15,[[10,[[0,[13,26,27]]]],[0,[13,26,27]]]]]],[7],0,[[1,28],1],[[17,17]],[[],1],[[29,30],[[31,[[10,[[0,[23,13,26,27]]]],[0,[23,13,26,27]]]]]],[[17,17],7],[7,8],[[17,17]],[1,1],[[[31,[[10,[[0,[23,13,26,27]]]],[0,[23,13,26,27]]]],32,33]],[[[31,[[10,[[0,[23,13,26,27]]]],[0,[23,13,26,27]]]],32]],[[[31,[[10,[[0,[23,13,26,27]]]],[0,[23,13,26,27]]]],32],[[34,[[24,[[10,[[0,[23,13,26,27]]]],[0,[23,13,26,27]]]]]]]],[[[11,[[10,[[0,[26,27]]]],[0,[26,27]]]],29,28],35],[[[24,[[10,[[0,[13,26,27]]]],[0,[13,26,27]]]],32,36],35],[1,[[5,[[37,[35]],[4,[3]]]]]],[[1,28],[[5,[[37,[35]],[4,[3]]]]]],[38],[38],[38],[[1,12],1],[[[31,[[10,[[0,[23,13,26,27]]]],[0,[23,13,26,27]]]],12],[[31,[[10,[[0,[23,13,26,27]]]],[0,[23,13,26,27]]]]]],[2,18],[[[15,[[10,[[0,[13,26,27]]]],[0,[13,26,27]]]]],34],[7,5],[12,5],[[1,18],1],[[],7],[8,7],[7,28],[7,28],[7,17],[[[15,[[10,[[0,[13,26,27]]]],[0,[13,26,27]]]]],[[39,[[0,[13,26,27]]]]]],[[[31,[[10,[[0,[23,13,26,27]]]],[0,[23,13,26,27]]]],36],[[31,[[10,[[0,[23,13,26,27]]]],[0,[23,13,26,27]]]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],35],[[],35],[[],35],[[]],[2,37],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],40],[[],40],[[],40],[[],40],[[],40],[[],40],[[],40],[[],40],[[],40],[[],40],[[],40],[[1,6],1],[[1,18],1],[[1,41],1],0,0,0,0,0,0,0,0,0],"p":[[3,"CTParserBuilder"],[3,"CTParser"],[8,"Error"],[3,"Box"],[4,"Result"],[4,"Visibility"],[3,"Span"],[3,"LexError"],[8,"Clone"],[8,"Lexeme"],[4,"Node"],[4,"RecoveryKind"],[8,"Hash"],[4,"ParseRepair"],[3,"ParseError"],[4,"Option"],[15,"usize"],[15,"bool"],[8,"PartialEq"],[3,"Formatter"],[6,"Result"],[3,"Error"],[8,"Debug"],[4,"LexParseError"],[8,"Iterator"],[8,"PrimInt"],[8,"Unsigned"],[15,"str"],[3,"YaccGrammar"],[3,"StateTable"],[3,"RTParserBuilder"],[8,"NonStreamingLexer"],[8,"Copy"],[3,"Vec"],[3,"String"],[8,"Fn"],[3,"HashMap"],[3,"Demand"],[3,"StIdx"],[3,"TypeId"],[4,"YaccKind"],[8,"Lexer"],[13,"LexError"],[13,"ParseError"],[13,"Term"],[13,"Nonterm"],[13,"Insert"],[13,"Delete"],[13,"Shift"],[13,"PublicIn"]]},\
"lrpar_tests":{"doc":"","t":[],"n":[],"q":[],"d":[],"i":[],"f":[],"p":[]},\
"lrtable":{"doc":"","t":[12,2,4,13,3,3,2,2,2,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,5,11,11,11,11,11,11,11,11,11,11,11,11,11,0,11,11,11,11,11,11,11,11,11,11,11,13,13,4,3,3,13,13,13,3,3,3,4,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12],"n":["0","Action","Minimiser","Pager","StIdx","StateGraph","StateTable","StateTableError","StateTableErrorKind","all_edges_len","all_states_len","as_storaget","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","closed_state","cmp","core_state","deserialize","edge","edges","eq","equivalent","fmt","fmt","from","from","from","from_yacc","hash","into","into","into","iter_closed_states","iter_core_states","iter_stidxs","partial_cmp","pp","pp_closed_states","pp_core_states","serialize","start_state","statetable","to_owned","to_owned","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","Accept","AcceptReduceConflict","Action","Conflicts","CoreReducesIterator","Error","Reduce","Shift","StateActionsIterator","StateTable","StateTableError","StateTableErrorKind","action","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","conflicts","core_reduces","deserialize","deserialize","deserialize","eq","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","goto","into","into","into","into","into","into","into","into_iter","into_iter","kind","new","next","next","pidx","pp","pp_rr","pp_sr","provide","reduce_only_state","rr_conflicts","rr_len","serialize","serialize","serialize","sr_conflicts","sr_len","start_state","state_actions","state_shifts","to_owned","to_string","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","0","0"],"q":["lrtable","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","lrtable::statetable","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","lrtable::statetable::Action",""],"d":["","","","","A type specifically for state table indices.","","","","","How many edges does this <code>StateGraph</code> contain?","How many states does this <code>StateGraph</code> contain? NB: By …","","","","","","","","","","","","Return the itemset for closed state <code>stidx</code>. Panics if <code>stidx</code> …","","Return the itemset for core state <code>stidx</code> or <code>None</code> if it doesn…","","Return the state pointed to by <code>sym</code> from <code>stidx</code> or <code>None</code> …","Return the edges for state <code>stidx</code>. Panics if <code>stidx</code> doesn’…","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Return an iterator over all closed states in this …","Return an iterator over all core states in this <code>StateGraph</code>.","Return an iterator which produces (in order from …","","Pretty print this stategraph as a <code>String</code>. If <code>core_states</code> …","Return a pretty printed version of the closed states, and …","Return a pretty printed version of the core states, and …","","Return this state graph’s start state.","","","","","","","","","","","","","Accept this input.","","","","","No valid action.","Reduce production X in the grammar.","Shift to state X in the statetable.","","A representation of a <code>StateTable</code> for a grammar. <code>actions</code> …","Any error from the Yacc parser returns an instance of this …","The various different possible Yacc parser errors.","Return the action for <code>stidx</code> and <code>sym</code>, or <code>None</code> if there isn…","","","","","","","","","","","","","","","","","Return a struct containing all conflicts or <code>None</code> if there …","Return an iterator over a set of “core” reduces of …","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Return the goto state for <code>stidx</code> and <code>ridx</code>, or <code>None</code> if there …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","Returns a pretty-printed version of the conflicts.","Returns a pretty-printed version of the reduce/reduce …","Returns a pretty-printed version of the shift/reduce …","","Does the state <code>stidx</code> 1) only contain reduce (and error) …","Return an iterator over all reduce/reduce conflicts.","How many reduce/reduce conflicts are there?","","","","Return an iterator over all shift/reduce conflicts.","How many shift/reduce conflicts are there?","Return this state table’s start state.","Return an iterator over the indexes of all non-empty …","Return an iterator over the indexes of all shift actions …","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[6,0,0,8,0,0,0,0,0,4,4,6,4,6,8,4,6,8,6,8,6,8,4,6,4,6,4,4,6,6,4,6,4,6,8,0,6,4,6,8,4,4,4,6,4,4,4,6,4,0,6,8,4,6,8,4,6,8,4,6,8,30,33,0,0,0,30,30,30,0,0,0,0,28,35,32,31,33,22,28,30,35,32,31,33,22,28,30,30,30,28,28,31,28,30,30,31,33,22,22,30,35,32,31,33,22,28,30,28,35,32,31,33,22,28,30,35,32,22,28,35,32,22,31,31,31,22,28,31,31,31,28,30,31,31,28,28,28,30,22,35,32,31,33,22,28,30,35,32,31,33,22,28,30,35,32,31,33,22,28,30,38,39],"f":[0,0,0,0,0,0,0,0,0,[[[4,[[0,[1,2,3]]]]],5],[[[4,[[0,[1,2,3]]]]],[[6,[[0,[1,2,3]]]]]],[[[6,[[0,[2,3]]]]],[[0,[2,3]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[[6,[7]]],[[6,[7]]]],[8,8],[[]],[[]],0,[[[6,[9]],6],10],0,[[],[[11,[6]]]],[[[4,[[0,[1,2,3]]]],[6,[[0,[1,2,3]]]],[12,[[0,[1,2,3]]]]],[[13,[[6,[[0,[1,2,3]]]]]]]],[[[4,[[0,[1,2,3]]]],[6,[[0,[1,2,3]]]]],14],[[[6,[15]],6],16],[[],16],[[[4,[[0,[17,18,1]]]],19],20],[[[6,[17]],19],20],[[]],[[]],[[]],[[21,8],[[11,[[22,[[0,[1,2,3]]]]]]]],[[[6,[1]]]],[[]],[[]],[[]],[[[4,[[0,[1,2,3]]]]],[[24,[23]]]],[[[4,[[0,[1,2,3]]]]],[[24,[23]]]],[[[4,[[0,[1,2,3]]]]],[[24,[23]]]],[[[6,[25]],6],[[13,[10]]]],[[[4,[[0,[1,2,3]]]],21,16],26],[[[4,[[0,[1,2,3]]]],21],26],[[[4,[[0,[1,2,3]]]],21],26],[6,11],[[[4,[[0,[1,2,3]]]]],[[6,[[0,[1,2,3]]]]]],0,[[]],[[]],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],27],[[],27],[[],27],0,0,0,0,0,0,0,0,0,0,0,0,[[[28,[[0,[1,2,3]]]],[6,[[0,[1,2,3]]]],[29,[[0,[1,2,3]]]]],[[30,[[0,[1,2,3]]]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[[30,[7]]],[[30,[7]]]],[[]],[[[28,[[0,[1,2,3]]]]],[[13,[31]]]],[[[28,[[0,[1,2,3]]]],[6,[[0,[1,2,3]]]]],[[32,[[0,[1,2,3]]]]]],[[],[[11,[31]]]],[[],[[11,[28]]]],[[],[[11,[30]]]],[[[30,[15]],30],16],[[[31,[17]],19],20],[[33,19],20],[[22,19],20],[[[22,[17]],19],20],[[[30,[17]],19],20],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[[28,[[0,[1,2,3]]]],[6,[[0,[1,2,3]]]],[34,[[0,[1,2,3]]]]],[[13,[[6,[[0,[1,2,3]]]]]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],0,[[21,4],[[11,[[28,[[0,[1,2,3]]]],[22,[[0,[1,2,3]]]]]]]],[[[35,[[0,[2,3]]]]],[[13,[[29,[[0,[2,3]]]]]]]],[[[32,[[0,[2,3]]]]],[[13,[[36,[[0,[2,3]]]]]]]],0,[[[31,[[0,[1,2,3]]]],21],26],[[[31,[[0,[1,2,3]]]],21],26],[[[31,[[0,[1,2,3]]]],21],26],[37],[[[28,[[0,[1,2,3]]]],[6,[[0,[1,2,3]]]]],16],[[[31,[[0,[1,2,3]]]]],23],[[[31,[[0,[1,2,3]]]]],5],[31,11],[28,11],[30,11],[[[31,[[0,[1,2,3]]]]],23],[[[31,[[0,[1,2,3]]]]],5],[[[28,[[0,[1,2,3]]]]],[[6,[[0,[1,2,3]]]]]],[[[28,[[0,[1,2,3]]]],[6,[[0,[1,2,3]]]]],[[35,[[0,[1,2,3]]]]]],[[[28,[[0,[1,2,3]]]],[6,[[0,[1,2,3]]]]],[[35,[[0,[1,2,3]]]]]],[[]],[[],26],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],0,0],"p":[[8,"Hash"],[8,"PrimInt"],[8,"Unsigned"],[3,"StateGraph"],[15,"usize"],[3,"StIdx"],[8,"Clone"],[4,"Minimiser"],[8,"Ord"],[4,"Ordering"],[4,"Result"],[4,"Symbol"],[4,"Option"],[3,"HashMap"],[8,"PartialEq"],[15,"bool"],[8,"Debug"],[8,"Eq"],[3,"Formatter"],[6,"Result"],[3,"YaccGrammar"],[3,"StateTableError"],[8,"Iterator"],[3,"Box"],[8,"PartialOrd"],[3,"String"],[3,"TypeId"],[3,"StateTable"],[3,"TIdx"],[4,"Action"],[3,"Conflicts"],[3,"CoreReducesIterator"],[4,"StateTableErrorKind"],[3,"RIdx"],[3,"StateActionsIterator"],[3,"PIdx"],[3,"Demand"],[13,"Shift"],[13,"Reduce"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
